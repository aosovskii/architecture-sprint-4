### Мотивация

**Ускорение работы системы**: Кеширование позволит хранить часто запрашиваемые данные в быстродоступном хранилище, что
ускорит доступ к ним и уменьшит нагрузку на БД и API.

**Увеличение производительности производительности**: Частые запросы к базам данных и API могут быть _узким горлышком_.
Кеширование этих запросов и ответов API значительно ускорит работу системы.

**Масштабируемость**: По мере роста системы и увеличения числа пользователей, кеширование поможет справиться с
нагрузкой, обеспечив быстрый доступ к данным из кеша.

**Сокращение _задержек_**: Хранение данных в кеше ближе к слою приложения сокращает время доступа к данным, улучшая
пользовательский опыт.

### Что кэшировать

- **Ответы API**: Кеширование ответов Shop API, CRM API и MEG API для часто запрашиваемых данных, таких как: каталоги
  продуктов или профили пользователей.

- **Результаты базовых запросов**: Кеширование результатов часто выполняемых запросов к БД Shop DB и MEG db, которые
  редко изменяются.

- **3D-файлы**: Кеширование часто используемых 3D-файлов для ускорения их извлечения, что ускорит процеесы рендеринга
  или визуализации.

### Предлагаемое решени

Предлагает использовать: **серверное кеширование**.

**Обоснование**:

- **Центразиованное управление**: Логика кешированияа находится на стороне сервера, что упрощает обслуживание и
  обновление. Отсюда, любые изменения данных или корректировки логики кэширования предстоит вносить только на стороне
  сервера.

- **Согласованность данных**: Управление инвалидацией кеша и согласованностью данных проще на серверной стороне. При
  изменении данных сервер может обновить или удалить соответствующие записи в кеше, обеспечивая актуальность данных для
  всех клиентов.

**Масштабируемость**: Серверное кеширование может улучшить производительность для всех клиентов, в то время как
клиентское кеширование работает только для отдельных клиентов.

**Сложность клиентского кеширования**: Реализация кеширования на стороне клиента может быть сложнее, особенно если
приложение доступно через различные типы клиентов (веб-браузеры, мобильные приложения), каждый из которых должен иметь
свою собственню реализацию кеширования.

Выбранный паттерн: **Cache-Aside**.

**Обоснвоание**:

- **Гибкость**: Cache-Aside позволяет независимо управлять кешем и основным хранилищем данных, что будет полезным в
  распределенных системах.

- **Управление устаревшими данными**: Cache-Aside дает возхможность контролировать время хранения данных в кеше (TTL) и
  реализовывать стратегии инвалидации кеша при изменении данных.

- **Уменьшение задержки записи**: В отличие от Write-Through, Cache-Aside не требует обновления кеша при каждой операции
  записи, что может снизить задержку в системах с высокой частотой записей.

- **Эффективность для систем с высокой частотой чтения**: В _read-heavy_ системах Cache-Aside значительно снизит
  нагрузку на основное хранилище данных, отдавая большинство запросов из кеша.

**Почему не другие подходят паттерны:**

- **Write-Through**: Вводит дополнительную задержку, особенно в случае высокой частоты записей, что может стать
  узким местом при росте нагрузок.

- **Refresh-Ahead**: Подходит для систем, где данные редко изменяются и имеют предсказуемый протокол доступа. В тех
  случаяхгде данные изменяются часто или непредсказуемым протоколом доступа - Refresh-Ahead может привести к устаревшим
  данным или ненужным обновлениям кеша.

| Инвалидация по ключу                                                       | Временная инвалидация                                                    | Программная инвалидация                                                    |
|----------------------------------------------------------------------------|--------------------------------------------------------------------------|----------------------------------------------------------------------------|
| Лучше подходит, потому что позволяет точечно обновлять кеш при изменениях. | Простая настройка с TTL, но не даёт точной гарантии актуальности данных. | Гибкая, но требует сложной логики для выявления зависимостей и обновлений. | 
| Особенности: 1) Простота реализации 2) Минимальная задержка на чтение.     | Особенности: 1) Подходит для часто меняющихся данных.                    | Особенности: 1) Подходит для систем со сложными взаимосвязями данных.      | 
| Не позволяет избежать частых перезаписей при больших нагрузках.            | Не всегда актуальные данные при большом TTL.                             | Сложность реализации и высокая стоимость вычислений.                       |